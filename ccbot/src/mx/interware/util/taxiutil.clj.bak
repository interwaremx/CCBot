(ns mx.interware.util.taxiutil  
  (:require [clojure.pprint :as pp]
            [clojure.xml :as xml]
            [clojure.string :as str]
            [clojure.tools.logging :as log]
            [clj-webdriver.taxi :as t]))

(do
  (println "loading " *ns*))

(def cmd->taxi {:open "t/to"
                :type "t/input-text"
                :clickAndWait "t/click"
                :click "t/click"
                :select "t/select-by-value"})

(def param-pattern #"([a-z]+)=(.*)")

(defn param-pattern-selector [drv param-type param-val]
  param-type)

(defmulti param-builder-fun param-pattern-selector)

(defmethod param-builder-fun :id [drv param-type param-val]
  (str "#" param-val))

(defmethod param-builder-fun :link [drv param-type param-val]
  (t/find-element drv {:xpath (str "//a[text()='" param-val "']")}))

(defmethod param-builder-fun :css [drv param-type param-val]
  (.replaceAll param-val "\"" "'"))

(defmethod param-builder-fun :xpath [drv param-type param-val]
  (t/find-element {:xpath param-val}))

(defmethod param-builder-fun :label [drv param-type param-val]
  param-val)

(defmethod param-builder-fun :name [drv param-type param-val]
  (str "[name=" (.replaceAll param-val "\"" "'") "]"))

(defmethod param-builder-fun :default [drv param-type param-val]
  param-val)

(defn param-builder [drv param]
  ;(println "param-builder:" param (re-matches param-pattern param))
  (let [mtchv (re-matches param-pattern param)]
    (if (vector? mtchv)
      (let [[_ param-type param-val] mtchv]
        (param-builder-fun drv (keyword param-type) param-val))
      (param-builder-fun drv :default param))))

(defn handle-open [base p]
  (let [p (.replaceAll p "\"" "")
        base (if (and (.endsWith base "/") (.startsWith p "/"))
               (str base (subs p 1))
               (str base p))]
    (str "\"" base "\"")))

(defn emit-taxi [base {:keys [cmd par1 par2]}]
  (let [taxi (cmd cmd->taxi)
        param [par1 par2]
        taxi-cmd (reduce 
                   (fn [s p]
                     (str s " " (if (= cmd :open) (handle-open base p) p)))
                   (str "(" taxi) 
                   (map param-builder (filter identity param)))]
    (str taxi-cmd ")")))

(defn leetrio [trio]
     (let [[e1 e2 e3] (:content trio)
           cmd (keyword (-> e1 :content first))
           par1 (-> e2 :content first)
           par2 (-> e3 :content first)]
       {:cmd cmd :par1 par1 :par2 par2}))

(defn read-selenium [file-uri]
  (log/debug "reading selenium tc:" file-uri)
  (let [src (xml/parse file-uri)
        dummy (pp/pprint src)
        base (-> src :content first :content second :attrs :href)
        tc-name (-> src :content first :content rest second :content first)
        cmds (-> src :content second :content first :content second :content)
        cmdsM (reduce 
                (fn [result trio]
                  (conj result (leetrio trio)))
                [base]
                cmds)]
    cmdsM))

(defn taxi-selector [drv base cmd]
  (cmd :cmd))

(defmulti exec-taxi taxi-selector)

(defmethod exec-taxi :open [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]
        path (param-builder drv (first (filter identity param)))
        url (str (java.net.URL. (java.net.URL. base) path))]
    (apply t/to [drv url])))

(defmethod exec-taxi :type [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]]
    (apply t/input-text (into [drv] (map (partial param-builder drv) (filter identity param))))))

(defmethod exec-taxi :clickAndWait [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]]
    (apply t/click (into [drv] (map (partial param-builder drv) (filter identity param))))
    (t/page-source drv)
    (comment
      (println "Tratando waitForPageToLoad")
      (let [r (.waitForPageToLoad (:webdriver drv) 30000)]
        (println "Regreso!!! :" r)))
    ))

(defmethod exec-taxi :click [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]]
    (apply t/click (into [drv] (map (partial param-builder drv) (filter identity param))))))

(defmethod exec-taxi :focus [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]]
    (apply t/focus (into [drv] (map (partial param-builder drv) (filter identity param))))))

(defmethod exec-taxi :select [drv base {:keys [cmd par1 par2]}]
  (let [param [par1 par2]]
    (apply t/select-by-value (into [drv] (map (partial param-builder drv) (filter identity param))))))

(defmethod exec-taxi :waitForVisible [drv base {:keys [cmd par1 par2]}]
  (t/wait-until drv 
                (fn [_]
                  (t/visible? drv (param-builder drv par1)))
                30000
                1000))

(defmethod exec-taxi :waitForText [drv base {:keys [cmd par1 par2]}]
  (try
    (t/wait-until drv 
                  (fn [_] 
                    (let [html (t/html drv (param-builder drv par1))]
                      (re-matches 
                        (re-pattern (str ".*" par2 ".*"))
                        html))) 
                  30000 
                  1000)
    (catch Exception e
      (log/warn e))))

(defmethod exec-taxi :waitForElementPresent [drv base {:keys [cmd par1 par2]}]
  (t/wait-until drv 
                (fn [_]
                  (t/present? drv (param-builder drv par1)))
                30000
                1000))

(defmethod exec-taxi :waitForPageToLoad [drv base {:keys [cmd par1 par2]}]
  (t/page-source drv))

(defmethod exec-taxi :waitForPopUp [drv base {:keys [cmd par1 par2]}]
  (let [web-driver (:webdriver drv)
        locator (.switchTo web-driver)
        nweb-driver (.window locator par1)]
    (.getPageSource nweb-driver)))

(defmethod exec-taxi :selectWindow [drv base {:keys [cmd par1 par2]}]
  (let [[llave name] (if (= "null" par1) [nil nil] (str/split par1 (re-pattern "=")))]
    (when (and llave (not= "name" llave))
      (throw (Exception. "selectWindow debe de ir con parametro 'null' o con el formato 'name=...'")))
    (log/info (str "name is " (if name name "nil") " param1= " par1))
    (if name 
      (t/switch-to-window drv name) 
      (t/switch-to-window drv 0))))

(defn exec-selenium [drv [base & cmds] delta]
  (try
    (reduce 
      (fn [delta-tot cmd]
        (Thread/sleep delta)
        (log/info (str cmd))
        (let [t0 (System/currentTimeMillis)]
          (try
            (exec-taxi drv base cmd)
            (catch Exception e
              (.printStackTrace e)
              (throw (Exception. (str cmd ":" e)))))
          (+ delta-tot (- (System/currentTimeMillis) t0))))
      0
      cmds)
    (catch Exception e
      (str e))))
